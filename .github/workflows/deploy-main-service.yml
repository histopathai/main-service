name: Deploy Main Service

on:
  push:
    branches:
      - main
      - dev
    paths:
      - 'infrastructure/**'
      - '.github/workflows/deploy.yml'
  pull_request:
    branches:
      - main
      - dev
    paths:
      - 'infrastructure/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - prod

env:
  TF_VERSION: '1.5.0'

permissions:
  contents: read
  id-token: write
  pull-requests: write

jobs:
  setup:
    name: Setup Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    steps:
      - name: Determine Environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV="${{ inputs.environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENV="prod"
          elif [ "${{ github.ref }}" == "refs/heads/dev" ]; then
            ENV="dev"
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            if [ "${{ github.base_ref }}" == "main" ]; then
              ENV="prod"
            else
              ENV="dev"
            fi
          else
            ENV="dev"
          fi
          
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "üåç Environment: ${ENV}"

  terraform-validate:
    name: Validate Terraform
    runs-on: ubuntu-latest
    needs: setup
    defaults:
      run:
        working-directory: ./infrastructure

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        id: fmt
        run: |
          echo "üîç Checking Terraform formatting..."
          if ! terraform fmt -check -recursive; then
            echo "‚ö†Ô∏è  Warning: Some files are not formatted correctly"
            echo "Run 'terraform fmt -recursive' to fix formatting"
            exit 0
          fi
          echo "‚úÖ All files are properly formatted"

      - name: Terraform Init
        id: init
        run: terraform init -backend=false

      - name: Terraform Validate
        id: validate
        run: terraform validate

      - name: Comment PR - Validation Results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const output = `### üîç Terraform Validation Results - Main Service
            
            | Check | Status |
            |-------|--------|
            | Format & Style üñå | \`${{ steps.fmt.outcome }}\` |
            | Initialization ‚öôÔ∏è | \`${{ steps.init.outcome }}\` |
            | Validation ü§ñ | \`${{ steps.validate.outcome }}\` |
            
            **Environment:** \`${{ needs.setup.outputs.environment }}\`
            **Triggered by:** @${{ github.actor }}`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [setup, terraform-validate]
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'

    env:
      WIF_PROVIDER: ${{ secrets.WIF_PROVIDER }}
      WIF_SERVICE_ACCOUNT: ${{ secrets.WIF_SERVICE_ACCOUNT }}
      TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
      TF_VARS_JSON: ${{ (needs.setup.outputs.environment == 'prod') && secrets.TF_VAR_MAIN_SERVICE_PROD || secrets.TF_VAR_MAIN_SERVICE_DEV }}

    defaults:
      run:
        working-directory: ./infrastructure

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify Required Secrets
        run: |
          echo "üîê Verifying secrets configuration..."
          
          MISSING_SECRETS=""
          
          if [ -z "${{ env.WIF_PROVIDER }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS}- WIF_PROVIDER\n"
          fi
          
          if [ -z "${{ env.WIF_SERVICE_ACCOUNT }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS}- WIF_SERVICE_ACCOUNT\n"
          fi
          
          if [ -z "${{ env.TF_STATE_BUCKET }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS}- TF_STATE_BUCKET\n"
          fi
          
          if [ -z "${{ env.TF_VARS_JSON }}" ]; then
            MISSING_SECRETS="${MISSING_SECRETS}- TF_VAR_MAIN_SERVICE_${{ needs.setup.outputs.environment == 'prod' && 'PROD' || 'DEV' }}\n"
          fi
          
          if [ ! -z "$MISSING_SECRETS" ]; then
            echo "‚ùå ERROR: Missing required secrets:"
            echo -e "$MISSING_SECRETS"
            exit 1
          fi
          
          echo "‚úÖ All required secrets are configured"

      - name: Create terraform.tfvars from JSON
        run: |
          echo "üìù Creating terraform.tfvars for ${{ needs.setup.outputs.environment }}..."
          
          cat << 'EOF' > parse_json.py
          import json
          import sys
          
          try:
              data = json.loads(sys.stdin.read())
              
              for key, value in data.items():
                  if isinstance(value, str):
                      print(f'{key} = "{value}"')
                  elif isinstance(value, bool):
                      print(f'{key} = {str(value).lower()}')
                  elif isinstance(value, (int, float)):
                      print(f'{key} = {value}')
                  elif isinstance(value, list):
                      items = ', '.join([f'"{v}"' for v in value])
                      print(f'{key} = [{items}]')
                  elif isinstance(value, dict):
                      print(f'{key} = {{')
                      for k, v in value.items():
                          if isinstance(v, str):
                              print(f'  {k} = "{v}"')
                          else:
                              print(f'  {k} = {v}')
                      print('}')
          except json.JSONDecodeError as e:
              print(f"ERROR: Invalid JSON format: {e}", file=sys.stderr)
              sys.exit(1)
          EOF
          
          echo '${{ env.TF_VARS_JSON }}' | python3 parse_json.py > terraform.tfvars
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to parse JSON"
            exit 1
          fi
          
          echo "‚úÖ terraform.tfvars created"

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.WIF_PROVIDER }}
          service_account: ${{ env.WIF_SERVICE_ACCOUNT }}

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: |
          echo "üîß Initializing Terraform..."
          terraform init \
            -backend-config="bucket=${{ env.TF_STATE_BUCKET }}"

      - name: Terraform Plan
        id: plan
        run: |
          echo "üìä Running Terraform plan..."
          terraform plan -no-color -out=tfplan
        continue-on-error: true

      - name: Save Plan Output
        if: success() || failure()
        run: terraform show -no-color tfplan > tfplan.txt

      - name: Comment PR - Plan Results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let plan = '';
            
            try {
              plan = fs.readFileSync('infrastructure/tfplan.txt', 'utf8');
            } catch (error) {
              plan = 'Unable to read plan output';
            }
            
            const maxLength = 60000;
            if (plan.length > maxLength) {
              plan = plan.substring(0, maxLength) + '\n\n... (truncated)';
            }
            
            const output = `### üìä Terraform Plan - Main Service (\`${{ needs.setup.outputs.environment }}\`)
            
            **Status:** \`${{ steps.plan.outcome }}\`
            
            <details><summary>üìñ Show Plan Details</summary>

            \`\`\`terraform
            ${plan}
            \`\`\`

            </details>

            **Triggered by:** @${{ github.actor }}`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      - name: Cleanup Sensitive Files
        if: always()
        run: rm -f terraform.tfvars

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: [setup, terraform-validate]
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.ref == 'refs/heads/dev' && github.event_name == 'push') ||
      github.event_name == 'workflow_dispatch'
    environment:
      name: ${{ needs.setup.outputs.environment }}

    env:
      WIF_PROVIDER: ${{ secrets.WIF_PROVIDER }}
      WIF_SERVICE_ACCOUNT: ${{ secrets.WIF_SERVICE_ACCOUNT }}
      TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
      TF_VARS_JSON: ${{ (needs.setup.outputs.environment == 'prod') && secrets.TF_VAR_MAIN_SERVICE_PROD || secrets.TF_VAR_MAIN_SERVICE_DEV }}

    defaults:
      run:
        working-directory: ./infrastructure

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create terraform.tfvars from JSON
        run: |
          echo "üìù Creating terraform.tfvars..."
          
          cat << 'EOF' > parse_json.py
          import json
          import sys
          
          try:
              data = json.loads(sys.stdin.read())
              
              for key, value in data.items():
                  if isinstance(value, str):
                      print(f'{key} = "{value}"')
                  elif isinstance(value, bool):
                      print(f'{key} = {str(value).lower()}')
                  elif isinstance(value, (int, float)):
                      print(f'{key} = {value}')
                  elif isinstance(value, list):
                      items = ', '.join([f'"{v}"' for v in value])
                      print(f'{key} = [{items}]')
                  elif isinstance(value, dict):
                      print(f'{key} = {{')
                      for k, v in value.items():
                          if isinstance(v, str):
                              print(f'  {k} = "{v}"')
                          else:
                              print(f'  {k} = {v}')
                      print('}')
          except json.JSONDecodeError as e:
              print(f"ERROR: Invalid JSON format: {e}", file=sys.stderr)
              sys.exit(1)
          EOF
          
          echo '${{ env.TF_VARS_JSON }}' | python3 parse_json.py > terraform.tfvars
          
          echo "‚úÖ terraform.tfvars created"

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.WIF_PROVIDER }}
          service_account: ${{ env.WIF_SERVICE_ACCOUNT }}

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: |
          echo "üîß Initializing Terraform..."
          terraform init \
            -backend-config="bucket=${{ env.TF_STATE_BUCKET }}"

      - name: Terraform Apply
        run: |
          echo "üöÄ Applying Terraform changes..."
          terraform apply -auto-approve

      - name: Terraform Output
        run: terraform output -json > terraform-outputs.json

      - name: Display Outputs
        run: |
          echo "üì§ Terraform Outputs (${{ needs.setup.outputs.environment }}):"
          echo "================================"
          terraform output

      - name: Upload Outputs
        uses: actions/upload-artifact@v4
        with:
          name: main-service-outputs-${{ needs.setup.outputs.environment }}
          path: infrastructure/terraform-outputs.json
          retention-days: 30

      - name: Cleanup Sensitive Files
        if: always()
        run: rm -f terraform.tfvars

      - name: Notify Success
        if: success()
        run: |
          echo "‚úÖ Main Service deployment successful!"
          echo "üåç Environment: ${{ needs.setup.outputs.environment }}"
          echo "üì¶ Pub/Sub topics and subscriptions deployed"

      - name: Notify Failure
        if: failure()
        run: |
          echo "‚ùå Main Service deployment failed!"
          echo "üåç Environment: ${{ needs.setup.outputs.environment }}"
          exit 1